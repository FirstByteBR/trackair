<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TrackAir - Monitoramento Ambiental</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link rel="icon" type="image/png" href="https://i.ibb.co/N2Dc3q53/logo.png">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@700;900&family=Segoe+UI:wght@400;700&display=swap" rel="stylesheet">

<style>
  :root {
    --bg-gradient: linear-gradient(60deg, rgba(23, 13, 194, 1) 0%, rgba(41, 41, 237, 1) 50%, rgba(0, 212, 255, 1) 100%);
  }

  body {
    margin: 0;
    padding: 0;
    font-family: 'Inter', sans-serif;
    color: #fff;
    background: var(--bg-gradient);
    background-attachment: fixed;
    overflow-x: hidden;
  }

  header {
    width: 100%;
    text-align: center;
    padding: 2rem 0 1rem 0;
    backdrop-filter: blur(6px);
  }

  h1 {
    font-size: 2.3rem;
    font-weight: 600;
    text-shadow: 0 0 15px rgba(255,255,255,0.2);
  }

  main {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    justify-items: center;
    gap: 40px;
    padding: 30px;
  }

  .card {
    width: 90%;
    max-width: 600px;
    background: rgba(255,255,255,0.08);
    border-radius: 20px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    padding: 25px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }
  .back{
    align-self:flex-start;
    color: white;
    border-width: 2pt;
    border-color:white;
    border-radius: 2pt;
  }
  .card:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 35px rgba(0,0,0,0.5);
  }

  canvas {
    width: 100%;
    height: 280px;
  }

  footer {
    text-align: center;
    font-size: 0.8rem;
    opacity: 0.7;
    margin-bottom: 20px;
  }
  :root {
            --text-color: white;
            --bg-gradient: linear-gradient(60deg, rgba(23, 13, 194, 1) 0%, rgba(41, 41, 237, 1) 50%, rgba(0, 212, 255, 1) 100%);
            --header-bg: rgba(0, 0, 0, 0.65);
            --section-bg: rgba(255, 255, 255, 0.1);
            --section-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            --button-bg: rgba(255, 255, 255, 0.2);
            --button-bg-hover: rgba(255, 255, 255, 0.35);
            --button-bg-active: rgba(255, 255, 255, 0.6);
            --button-radius: 10px;
            --section-radius: 20px;
            --widget-bg: rgba(255, 255, 255, 0.1);
            --widget-bg-hover: rgba(255, 255, 255, 0.2);
            --widget-radius: 8px;

            --font-primary: 'Segoe UI', sans-serif;
            --font-display: 'Rubik', sans-serif;

            --header-height: 70px;
        }
</style>
</head>
<body>
  <header>
    <a href="index.html" class="back">Voltar</a><h1 class="title">TrackAir • Monitoramento</h1>
  </header>

  <main>
    <div class="card">
      <canvas id="chartTemp"></canvas>
    </div>
    <div class="card">
      <canvas id="chartCO2"></canvas>
    </div>
    <div class="card">
      <canvas id="chartPM25"></canvas>
    </div>
  </main>

  <footer>
    Atualização automática a cada 10s • Baseado em dados do sensor remoto
  </footer>

<script>
const ENDPOINT = "https://trackair-live.davimquerino2009.workers.dev";

function parseTXT(texto) {
    const blocos = texto.trim().split(/Cod:/).filter(Boolean);
    const dados = blocos.map(b => {
        const cod = b.match(/(\d+)/)?.[1] || null;
        const chave = b.match(/Chave:\s*(\S+)/)?.[1] || null;
        const data = b.match(/Data:\s*([0-9:\-\s]+)/)?.[1] || null;
        const dadoStr = b.match(/Dado:\s*(.+?)\s*Data:/s)?.[1]?.trim() || "";
        const dadosMedidos = {};
        dadoStr.split(";").forEach(par => {
            const [k, v] = par.split(":");
            if (k && v) dadosMedidos[k.trim()] = parseFloat(v);
        });
        return { Cod: cod, Chave: chave, Data: data, Dados: dadosMedidos };
    });
    return dados;
}

let charts = {};
let lastLabels = [];

function initCharts() {
  const ctxTemp = document.getElementById("chartTemp")?.getContext("2d");
  const ctxCO2 = document.getElementById("chartCO2")?.getContext("2d");
  const ctxPM25 = document.getElementById("chartPM25")?.getContext("2d");

  charts.temp = new Chart(ctxTemp, {
    type: "line",
    data: { 
      labels: [], 
      datasets: [{ 
        label: "Temperatura (°C)", 
        data: [],
        borderColor: "rgba(255, 99, 132, 1)",
        backgroundColor: "rgba(255, 99, 132, 0.1)",
        fill: true,
        pointRadius: 0, // Removido os pontos
        tension: 0.35,
        borderWidth: 2
      }] 
    },
    options: { 
      responsive: true,
      animation: false,
      plugins: {
        legend: {
          labels: { color: "#fff", font: { size: 14 } }
        }
      },
      scales: {
        x: {
          ticks: { 
            color: "#fff",
            maxTicksLimit: 6, // Limita número de timestamps
            callback: function(value, index, values) {
              // Mostra apenas alguns timestamps para não poluir
              if (index === 0 || index === values.length - 1 || index % Math.ceil(values.length / 5) === 0) {
                return this.getLabelForValue(value);
              }
              return '';
            }
          },
          grid: { color: "rgba(255,255,255,0.1)" }
        },
        y: {
          ticks: { color: "#fff" },
          grid: { color: "rgba(255,255,255,0.1)" },
          beginAtZero: false
        }
      }
    }
  });

  charts.co2 = new Chart(ctxCO2, {
    type: "line",
    data: { 
      labels: [], 
      datasets: [{ 
        label: "CO₂ (ppm)", 
        data: [],
        borderColor: "rgba(54, 162, 235, 1)",
        backgroundColor: "rgba(54, 162, 235, 0.1)",
        fill: true,
        pointRadius: 0, // Removido os pontos
        tension: 0.35,
        borderWidth: 2
      }] 
    },
    options: { 
      responsive: true,
      animation: false,
      plugins: {
        legend: {
          labels: { color: "#fff", font: { size: 14 } }
        }
      },
      scales: {
        x: {
          ticks: { 
            color: "#fff",
            maxTicksLimit: 6,
            callback: function(value, index, values) {
              if (index === 0 || index === values.length - 1 || index % Math.ceil(values.length / 5) === 0) {
                return this.getLabelForValue(value);
              }
              return '';
            }
          },
          grid: { color: "rgba(255,255,255,0.1)" }
        },
        y: {
          ticks: { color: "#fff" },
          grid: { color: "rgba(255,255,255,0.1)" },
          beginAtZero: false
        }
      }
    }
  });

  charts.pm25 = new Chart(ctxPM25, {
    type: "line",
    data: { 
      labels: [], 
      datasets: [{ 
        label: "PM2.5 (µg/m³)", 
        data: [],
        borderColor: "rgba(75, 192, 192, 1)",
        backgroundColor: "rgba(75, 192, 192, 0.1)",
        fill: true,
        pointRadius: 0, // Removido os pontos
        tension: 0.35,
        borderWidth: 2
      }] 
    },
    options: { 
      responsive: true,
      animation: false,
      plugins: {
        legend: {
          labels: { color: "#fff", font: { size: 14 } }
        }
      },
      scales: {
        x: {
          ticks: { 
            color: "#fff",
            maxTicksLimit: 6,
            callback: function(value, index, values) {
              if (index === 0 || index === values.length - 1 || index % Math.ceil(values.length / 5) === 0) {
                return this.getLabelForValue(value);
              }
              return '';
            }
          },
          grid: { color: "rgba(255,255,255,0.1)" }
        },
        y: {
          ticks: { color: "#fff" },
          grid: { color: "rgba(255,255,255,0.1)" },
          beginAtZero: false
        }
      }
    }
  });
}

function formatarTimestamp(dataString) {
  if (!dataString) return '';
  
  try {
    const date = new Date(dataString);
    // Formata como HH:MM (apenas hora e minuto)
    return date.toLocaleTimeString('pt-BR', { 
      hour: '2-digit', 
      minute: '2-digit'
    });
  } catch (e) {
    return dataString; // Fallback para o formato original se der erro
  }
}

function atualizarPlot(dados) {
  if (!charts.temp || !charts.co2 || !charts.pm25) {
    console.warn("atualizarPlot: objetos charts não inicializados");
    return;
  }

  // Usar timestamps formatados (apenas hora e minuto)
  const labels = dados.map(item => formatarTimestamp(item.Data));
  
  // Extrair os dados corretamente
  const tempData = dados.map(item => {
    const dados = item.Dados || {};
    return dados.Temperatura || dados.temp || dados.TEMP || 0;
  });
  
  const co2Data = dados.map(item => {
    const dados = item.Dados || {};
    return dados.CO2 || dados.co2 || dados.CO2 || 0;
  });
  
  const pm25Data = dados.map(item => {
    const dados = item.Dados || {};
    return dados.PM25 || dados.pm25 || dados['PM2_5'] || dados.pm2_5 || 0;
  });

  console.log("Dados processados:", { tempData, co2Data, pm25Data, labels });

  // Atualizar apenas se os labels mudaram significativamente
  const shouldUpdateLabels = JSON.stringify(labels) !== JSON.stringify(lastLabels);
  
  if (shouldUpdateLabels) {
    charts.temp.data.labels = labels;
    charts.co2.data.labels = labels;
    charts.pm25.data.labels = labels;
    lastLabels = labels;
  }

  charts.temp.data.datasets[0].data = tempData;
  charts.co2.data.datasets[0].data = co2Data;
  charts.pm25.data.datasets[0].data = pm25Data;

  charts.temp.update('none');
  charts.co2.update('none');
  charts.pm25.update('none');
}

async function atualizarGraficos() {
  try {
    const resp = await fetch("https://trackair-live.davimquerino2009.workers.dev/");
    const texto = await resp.text();
    console.log("Resposta da API:", texto);
    
    const dadosParseados = parseTXT(texto);
    console.log("Dados parseados:", dadosParseados);
    
    atualizarPlot(dadosParseados);
  } catch (e) {
    console.error("Erro ao buscar dados:", e);
  }
}

// Inicialização garantida após DOM carregar
document.addEventListener("DOMContentLoaded", () => {
  initCharts();
  atualizarGraficos();
  setInterval(atualizarGraficos, 10000);
});
</script>
</body>
</html>